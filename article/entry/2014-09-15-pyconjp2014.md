tags: python
---
# PyConJP 2014 感想

Perl以外の言語コミュニティ、カンファレンスに顔を出すのははじめてでしたが色々新鮮で面白かった。

## 全体的な印象

- pythonの話の割合が高い
- アカデミックな感じもあった
- 運用の話はほとんどなかった
    - 懇親会でもあんまりそういう話は出なかった
- ロマン枠もあってロマンがあった
- 来てる人(と話した感じ)
    - もそんな感じで需要と供給が合ってる感じ
    - 仕事では使ってない人も結構いらした
- YAPC::ASIAと比べて真面目で落ち着いた印象

## 全体のメモが長いので、特に気になったところをピックアップ

- Djangoアプリケーション、パフォーマンスチューニング
    - Djangoに限らず、パフォーマンスチューニングの手法として参考になった
    - ORMがどんなSQLを吐くのかを把握することは大事
    - Funkloadでシナリオテストを並列でがっつりできるので実利用時のパフォーマンステストによい
- [リファクタリングツールあれこれ — pyconjp2014 1 documentation](http://tell-k.github.io/pyconjp2014/#/ "リファクタリングツールあれこれ — pyconjp2014 1 documentation")
    - 紹介されているツールをちゃんと使いこなさないと死ぬ
- Pyramid入門
    - SQLAlchemyが難しいけどよいらしいので手を出したい
- 2日目キーノート
    - エンジニアの学び方、コーディングを支える技術は読んでみたい
    - U理論まずはこれで勉強: [オットー・シャーマー「U理論」の要約：ニュース＆トピックス｜チェンジ・エージェント](http://change-agent.jp/news/archives/000133.html "オットー・シャーマー「U理論」の要約：ニュース＆トピックス｜チェンジ・エージェント")
- PythonistaでiOSホビープログラミング(ポスターセッション)
    - iOSでpythonが動かせるPythonistaちょうほしい
- Secure Code for Interactive Programming(オープンスペース)
    - ブラウザでインタラクティブにpythonが書けるIPython Notebook楽しそう
        - グラフがポンと出るのすごい
    - 省メモリプログラミングちゃんとしたい
        - ジェネレータとか
        - [yieldのちょっとした理解](http://giraffe.topaz.ne.jp/wiki/doku.php/py:lesson14 "yieldのちょっとした理解")

それでは以下、長いメモと若干の感想です。

## Keynote 1日目

- ビデオとスライド: [Talks — Kenneth Reitz](http://www.kennethreitz.org/talks#/python-27-python-3-a-sacred-love-story/ "Talks — Kenneth Reitz")
- 感想
    - (プログラミング言語じゃなくて一般的な)言語としてというあたりはよくわからず
    - 言語としての思想を聞けたのは良かった
    - python2/3の分断はつらい
        - コア開発者とコミュニティが分断されてる感じも受けてつらい
        - python3もがっつり使って意見出すというのは必要だと思うけどがっつりというあたりがハードル高い
        - YAPC::ASIAでオープンソースの開発がどうやって進んでるかみたいな話があったので、聽いて比べてみたい感
            - [オープンソースの開発現場 - Perl 5.20 のSubroutine Signaturesが来るまでの奮闘の軌跡 - YAPC::Asia Tokyo 2014](http://yapcasia.org/2014/talk/show/c06cb1ae-ec5f-11e3-bd6d-c7a06aeab6a4 "オープンソースの開発現場 - Perl 5.20 のSubroutine Signaturesが来るまでの奮闘の軌跡 - YAPC::Asia Tokyo 2014")
- 言語について
    - プログラミング言語というくくりではなく、人が話す言語として考えてみる
    - 概念を言葉で伝える、人とコミュニケーションができる
    - 保存できる、他の人に伝えたり配信できる
    - 言葉というソフトがアップグレードされていく
- コミュニケーション
    - 最初は1対1、小さなコミュニティ
    - 手紙の起源
    - 1対多: 何千を相手にコミュニケーションが取れる
        - 大衆という概念を生む
    - 多対多: インターネット
- テクノロジーがあるのと同じ、
- PythonのZen: Import this.
    - Beautiful is better than ugly.
        - 醜悪なものより美しいもの
    - Explicit is better than implicit.
        - 暗黙よりも明白
    - Simple is better than complex.
        - 複雑よりシンプル
    - Complex is better than complicated.
        - わかりにくいよりは複雑
- Pythonの未来
    - python2/python3
    - python3のほうが少ない
        - perl6よりマシよね
        - 私も使ってない
    - python3はpythonとは違う言語
    - unicodeとcodecがpython3を壊した
    - python3で standard libraryが壊れている
        - 多くのstandard libraryが使われていない
        - 直りつつある
        - python3のユーザーがいないから直ってない
    - ダウンロード数がまったく違う
    - 初学者がpython3を使う
    - プロダクトを作っても市場が無い
    - 私たちが問題でソリューション
    - python3を体験して、体験をシェアしよう
- 質疑
    - perl5と6みたいに別な言語として歩む方向ではないのか？
        - 変換ツールはあるけど完璧ではない
        - ライブラリは両方のバージョンで動くようになってる
        - みんなが声を上げてくれれば、我々も次になにをすべきかわかる
            - python3のいいところをバックポートしていくというアプローチもある
        - python2.8はない、2.7で終わり
    - Python3のベネフィットは？
        - ないです。好きじゃない
        - 新しい機能は色々追加されてる
    - 言語仕様の標準化について
        - python2.7は最新の安定した言語バージョン
    - Python3についてのコミュニケーションがクリアに行われていないのでは？
        - クリアなビジョンはないと思う
        - 今までのコミュニケーションはマズイ
        - オフィシャルなストーリーが語られていないのは、ストーリーが形成されていないから
        - コミュニティが自然とストーリーを見出すことを期待できない
    - みんなの意見としてはPython2が選ばれているのが明らかでは？
        - コア開発者は10年かかるけど変わっていくと考えてる
        - 今のギャップについてはコア開発者は気にしてない
        - python2.7をみんなが使って、3は忘れてしまい
            - それがみんなの意見として出ればいいね
    - python3のサポートのニーズが増えてきている
    - rubyの1→2は受け入れられた
        - rubyは急激な変更だった
        - pythonはstableなものに慣れてて、変化に慣れてなかった
        - scientificなバックグラウンドがあった
        - rubyはコア言語がどんどん変わる、ポイントリリースでもパッチリリースでも変わる
            - rubyはそういう文化、変化に慣れてて、変更の利点を享受できてる
        - python2/3もそうであるべきと思うが
    - Python3の優れたところをPython2に取り込んでは
        - それが理想的
        - そういう声を上げて

## Djangoによるスマホアプリバックエンドの実装 (ja)

- スライド: [Djangoによるスマホアプリバックエンドの実装](http://www.slideshare.net/nakazawayuichi/pycon-rev005 "Djangoによるスマホアプリバックエンドの実装")
- 感想: 
    - 開発プロセスが聞けたのがよかった
- Djangoのメリット
    - 管理サイトを簡単に作れる
- 構成(バックエンドの)
    - 管理サイト + API
- CMSの部分
    - まずモデルを作る 本(1) - 感想(多) 的な
    - Djangoに用意されているORMでDBにアクセスする
        - 1対多, 多対多のリレーションができる
            - 中間テーブルができるが、使用側は意識しない
    - ORMをつかってモデル図をつくる
    - アグリゲーションを使いこなすのが大事
        - って何
        - パフォーマンス的にも、全部呼んでプログラム内で回すより、SQL一発にまで落としこむ
    - DB migration
        - モデルの変更を拾って、マイグレーションファイルを作る
        - それを使ってDBに反映する
    - Bootstrap
        - Djangoのテンプレート継承機能を使う
- API部分
    - スマホとの連携部分
    - JSONを自前で書く
    - Orderddict: 順序付き辞書(python2.7〜)
- push通知
    - iOS: PyAPNs
        - デバイストークンの収集が必要
            - 端末のトークン？
    - Android: python-gcm
        - デバイストークンの収集が必要
- ログインパスワードの暗号化
    - AESがよい
    - ログイン連携: python-social-auth
        - OpenID Connectとの連携は未対応
        - 自前で拡張したコードを後悔してる
- インフラ
    - s3にデータをアップして、URLを取得してDBに突っ込む
    - nginx + uWSGI
        - emperer と家臣モデルで使ってる
    - デプロイ時のオートリロード
        - 比較的簡単にできる
- Djangoのチュートリアル書いた(Qiita)

## Djangoアプリケーション、パフォーマンスチューニング

- スライド: [Pycon2014 django performance](http://www.slideshare.net/hirokiky/pycon2014-django-performance-39037314?utm_source=dlvr.it&amp;utm_medium=twitter "Pycon2014 django performance")
- 感想: 
    - Djangoに限らず、パフォーマンスチューニングの手法として参考になった
    - ORMがどんなSQLを吐くのかを把握することは大事
    - Funkloadでシナリオテストを並列でがっつりできるので実利用時のパフォーマンステストによい
- 一番需要なのはORMの扱い方
    - ボトルネックになりやすいのはDB
- SQLを吐きまくるコードを見つける
    - django-debug-toolbar
        - ツールバーにいろんなデバッグ情報が出る
        - SQLパネルを使う
        - 例: 何かしらの一覧を出す画面
            - SQLのパネルを出す: 12のクエリが発行されたことがわかる
    - dbログ出力
        - 画面以外(APIとか)のときに有効
- SQLを吐きまくるコードを倒す: ORMの最適化
    - select_related
        - FK先のデータも一緒に取ってくる(内部的にはINNER JOIN)
        - 駄目な例:
            - article.autherは別テーブルの値
            - ループの元になるクエリではautherは取ってこない
                - ループ内で都度取ってくる
        - 改善例: 
            - INNER JOINを使う
            - Djangoでは: select_relatedをつかって、別テーブルの値も一緒に取ってくる
    - prefetch_related
        - select_relatedとの差異は？
        - 例: 一つのブログ記事に複数のタグが付いてる時
            - many to manyの関係になるので、中間テーブルが作られる
                - for の繰り返し毎に
            - select_relatedでは解消できない
        - 解決策: 
            - それぞれのテーブルから値を取ってきて、Django側で結合(して中間テーブルを作成)、そこからデータを取る
    - bulk_create
        - mysqlのbulk insertみたいなもの
        - 10回ループで入れるんではなく、bulk insertで一発で浮いれる
    - update
        - オブジェクトで一つずつ取ってきて値を変えてセーブより早い
    - exist
        - 有無を確認するならcountは使わないでexistを使う
        - existはLIMIT 1でSQLを実行するので早い
    - only, defer: 
        - 取得してくるフィールドを指定する
        - 使わないとselect * from hoge
        - 使った上で取ってきてない値を取ろうとするとそこでクエリが発行される
    - values, values_list: 
        - 辞書|タプルのリストとしてデータを取得
        - コードが複雑化しやすいので使うところは限定的にしたほうがよいよ
    - このあたりを使いこなすといいよ
    - ORMはRDBを隠蔽するものでは？: 結局RDBを相手にしているのでね……
- インデックス
    - 検証環境にデータをたっぷり入れてやるのがオススメ
    - JetProfiler for MySQLを使うのもオススメ
    - extra, raw: クエリ{の一部,}を生SQLで書くためのもの
    - 結局テーブルの設計の問題に落ち着きがち
- キャッシュ
    - 使うことでアプリケーションの複雑化にもつながる
    - 何をキャッシュするか
        - 効果があるほど適用が難しい
    - 使い所
        - ユーザに依存するところはキャッシュ無理
        - 画面設計段階で、どこをキャッシュするのか考えるべき
    - redisでキャッシュ
        - 型を有効活用できる
- アプリケーション外
    - セッションバックエンド
        - 通常はDB
        - redisとかにできる
    - 静的ファイル圧縮
        - djang-compressor
        - django-
    - Master-Slave構成
        - django-replicated: レプリケーション遅延にも対応できる
        - GET, HEADはslave, それ以外master
        - めっちゃ楽そう
- Funkload(シナリオテスト)
    - いろんなテストの書き方の例
    - レポート出せる
- まとめ
    - ORMの扱い方を把握するのは基本, まずそれをやる
    - あとは測定しながら必要なところに手を入れる
    - 結局設計とミドルが重要、どう"うまく"使うかを考えて適用していく
- 質疑
    - new rericで検証とかは？
        - 常に検証して、みたいなことはやったこと無い
    - Fankloadは全部pythonで書かれている
        - ツールもpythonで書かれているし、テストもpythonで書く
    - Fankloadのテストでクライアント側がネックになることは？
        - 並列数を増やせば普通にある
        - 台数を増やして対応する
    - 複数のクライアントでやったときに結果をまとめることは？
        - わからない
        - クライアントをEC2のLargeとかでかいインスタンス立てて、1台で200並列とかできた

## XML-RPC

- XML-RPCとは
    - 古い技術
    - RESTplus JSONに置き換えられてる
    - でも便利に使える
- Remote Procedure Callとは
    - ローカルのマシンで関数を呼ぶと、外部のサービスに接続して値を取ってくる、みたいな
    - Sun RPCが有名、現役でも使われてる
    - webとRPCの違いは？
        - RPCは普通に呼び出す関数を書く感じで使う
            - HTTPのGETメソッドの投げ方とかを意識しなくていい、簡単
        - そういう概念的なもの
        - イメージ: Remote側の処理と、ローカル側にそれを呼び出す関数がある
- 作り方
    1. IDL(Interface Definision Language, InterfaceのDSLみたいなもの)を書く
    2. IDL Compilerにかける
    3. リモート側とローカル側のstubができる
    4. stubを埋める形でインタフェースを定義する
- XML-RPC
    - 中身はXML
    - HTTPで通信
    - ほとんどREST、当時はJSONしかなかった
    - XML-RPCが発展してSORPができた
- なんでXML-RPC？
    - pythonの標準ライブラリにある
        - クライアント・サーバ両方ある
- Hello World
    - サーバ側: SimpleXMLRPCServer
        - 裏ではSimpleHTTPServerが動いてる
- 日々の道具としてXML-RPCライブラリを使う
    - サーバ側のRequestHandlerとクライアントのClientメソッドを常に同じくなるよう変更する

## リファクタリングツールあれこれ

- スライド: [リファクタリングツールあれこれ — pyconjp2014 1 documentation](http://tell-k.github.io/pyconjp2014/#/ "リファクタリングツールあれこれ — pyconjp2014 1 documentation")
- 感想
    - リファクタリングするためのツールだけど
    - コードをきれいに書くために必須っぽいツールでもあった
    - やんないでリポジトリに上げたりしたら殺されそう
- リファクタリングの話はしない
- コーディング規約
    - PEP8
    - PEP257
- チェックするツールがある
- flake8
    - pep8 + pyflake 中で使ってる
    - vim-flake8
    - setup.cfgでチェックする規約をカスタマイズできる
    - VCS HOOKで自動でチェックが走るようにもできる
    - 拡張も色々
    - コーディングスタイル
        - コミュニティ推奨のスタイルがある
- 自動整形
    - autopep8
        - フォルダ内をまとめてできる
    - autoflake
        - pyflakesの出すメッセージに対応する感じ
    - pyformat: 統合されてるけど制度がよくない、怖そう
- 自動補完
    - Docstringを表示
    - 定義場所にJump
- リファクタリング
    - Rope
        - jediと若干被る
        - renameとか
        - ropeプロジェクトを作って、その中で設定する
    - RopeRename
    - RopeAutoImport
    - 継承先の実装箇所を探してくれるやつ
    - 選択範囲をメソッド化、文脈を読んで引数をよしなにしてくれる
    - RopeUndo/RopeRedo: gitとか使ってたらあんまり恩恵はない
    - ショートカット一覧で機能一覧も見れる
    - プレビュー可
- コードメトリクスを見る
    - リファクタリング対象を探す
    - 複雑になりすぎてないかチェック
    - Code Climate: githubのコードを評価してくれるサービス
        - pythonはまだだめ
    - 複雑度の指標がある
    - Radonで6段階で評価
    - Qiitaのradon記事がよい
- Sentry: Django製ログトラッキングツール
    - コードメトリクスの評価が高ければ必ずしも良いわけではない
    - 適切なリファクタリング対象を探す
    - デッドコードを探す
    - カバレッジをとるのがおすすめ
- 注力すべき作業に集中しよう

## Pyramid入門

- スライド: [Pyramid入門](http://www.slideshare.net/aodag/pyramid-39068836 "Pyramid入門")
- 感想
    - 入門部分速攻で終わった
    - SQLAlchemyが難しいけどよいらしい
    - がんばって使いこなせるようになりたいです
- Pyramidとは
    - ドキュメントがしっかりしてる
    - コンポーネントで拡張できる
    - 何を使っていいのかわからない
    - MVCの部分しか持ってない
- SQLAlchemy(ORマッパー)と一緒に使いたいときに良い
- フルスタックがいらない場合につかう(DB使わない場合など)
- pyvenv(2.7ならvirtualenv)で仮想環境
- pipでインストール
- viewはリクエストを受け取ってレスポンスを返すところ
- pyramid_tm, pyramid_sqlarchemy
- テンプレートサポート:json, stringのみ
    - makoとかはサポート外れてライブラリサポートとなった
    - バージョンアップで減る
- Viewが呼ばれるまでのプロセス
- 細々した処理をadopterに逃がして、viewをシンプルにする
- ビューに詳細を実装したくないので、appstractをなんちゃらに書く
- view_configにパーミッション設定が入る
- リソースとコンテキストをうまくつかう
- ビューとモデルの緩衝材
- WAFでの開発の仕方とか、書き方の思想とか、そういう話
- GODBとピラミットは相性がいい

## LT

- ネタ発表あんまりない
- 世界樹の地図を作るアプリの話がいい話だった
- グノシーのアドサーバ: Tornado + PyPy で高速APIサーバ

## Keynote 2日目

- 感想
    - 人間へのインプットスピードが進化してない、確かに……
        - でも適切な情報に早くアクセスできるようにはなってるので、そういう意味ではスピードアップしてるのでは
    - エンジニアの学び方、コーディングを支える技術は読んでみたい
    - U理論も気になる
        - 本も出てるけど厚いし高い
        - まずはこれで勉強: [オットー・シャーマー「U理論」の要約：ニュース＆トピックス｜チェンジ・エージェント](http://change-agent.jp/news/archives/000133.html "オットー・シャーマー「U理論」の要約：ニュース＆トピックス｜チェンジ・エージェント")
- サイボウズでのpython
    - インフラ
        - リモートバックアップ
        - つくよみ(漢字)
            - P2P, エージェントがいてリカバリする(?)
    - 解析
        - NumPy, SciPyで統計処理
- kintone
    - github: 貯めたコードのまわりでコミュニケーション
    - kintone: 貯めた仕事に関係するデータのまわりでコミュニケーション
        - グラフの種類をレコメンデーション
- コンピュータが人間のレベルに追いつく？
- 人間はコンピュータに増強されてる、さらに増強するには、という方法
- 人間のモニタリング
    - 自身でモニタリングすると、自分が不調な場合に適切にモニタリングもできない
    - 他人がモニタリングすることでカバー
    - コンピュータがモニタリングすれば、より適切にできるのでは
- 人間 - 機械間のインタフェース
    - Human → Machine: keyboard, mouse, sensor, ...
    - Machine → Human: CRT, e-ink, sound, ...
        - 紙の本の時代と比べて、人間へのインプットスピードは進化してない
- 人間増強の四要素: エンゲルバード
- 知らないものを発見する方法論
    - 発見するためには、視点を変える必要がある
    - 詳しくなればなるほど、そのバイアスに縛られて、反対側が見えなくなる
    - known : unknown の対立は正しくない
    - known(明らかに知ってる) : 不明(見えてないのに、見えてないことに気づいてない) : unknown(知らないことを知ってる)
- コーディングを支える技術: 比較して学ぶ、歴史から学ぶ、経験して学ぶ
    - その後 + 抽象から学ぶ、対話から学ぶ
        - 対話から学ぶ: エンジニアの学び方
    - 比較して学ぶ例: 他の言語との差異"0はTrue?False?"
        - non zero methodをググるべし
    - 歴史: pythonにクラスが2種類あるけど、なんで？
    - 経験: やってみたら違った 1/2 → 0
    - 抽象: 知らずにやってきた書き方のデザインパターンを知る
    - 対話: サーバ周りをやってるひとが、GUIの人と話をしてイベントドリブンを知る
- U理論
    - 他の人と共有していくのはどうやってという感じ
    - ぐぐってみよう
- 自分の理解に基づいて行動する
    - 結果が違ったら自分の側のモデルを変える
    - 人文系: KJ法
        - データを可能な限り集めて見える範囲に広げる
        - そのデータから抽象化して云々

## ポスターセッション

ポスターとか卓上デモを出してるブースが並んで来た人が話を聞くみたいな感じの企画。学会っぽい？学会よく知らないけど。

### PythonistaでiOSホビープログラミング

- iOSでpythonが動かせる"Pythonista"の紹介とデモ
- コードも書けるし実行もできる
- iOSのコンポーネントも使える
- これは欲しい

### MCU Gear mini

- ハードウェア系のデモ
- いろんな機能を持つ基盤を、ブロックを組むように積み上げていくと、勝手に配線してくれる
- Raspberry Pi上でpythonが動いてて、そこでつながったモジュールを認識して、勝手に配線してくれるとのこと
- pythonにはハードウェア系のモジュールが大体揃ってるからつかいやすいのだとか
- 回路情報をpythonで持っててそれに沿って配線するみたいな話だったと思うけど忘れちゃった

### Probabilistic Programming with Python

- 確率プログラミング #とは
- MLより手軽に扱えるもの、らしい
    - ML知らないしググってもわからない……
- 確率計算をする際に、既知の知見を加えられる
- 少ないデータでも計算できるから、大まかな確率を知ったり、どの程度のデータがあれば精度が高まるのかの指標になったりもする

### Marsface Project - 画像認識に基づく火星および太陽系惑星群の構造物探索

- [Marsface Project](http://marproject.org/ "Marsface Project")
- NASAのフリー画像を延々と顔認識させる
- フィルタを緩くするといろんなモノが引っかかる

## OpenSpace

アンカンファレンスっぽい感じで、時間枠に発表したい人が付箋で内容をペタペタ貼っていってセッションが決まる感じの。枠は半分くらい空いてて、聴衆も少なめ。面白かっただけにもったいない。

### Secure Code for IPython Notebook

- スライドとか: [hagino3000's blog: PyCon JP 2014 オープンスペースでインタラクティブプログラミングについて発表しました](http://hagino3000.blogspot.jp/2014/09/pycon-jp-2014.html "hagino3000's blog: PyCon JP 2014 オープンスペースでインタラクティブプログラミングについて発表しました")
- 感想
    - IPython Notebook初見でした。楽しそう
    - 大量データを扱う場合はメモリにやさしいプログラミングをしないと死ぬという事
    - ジェネレータ？という状態だったので死ぬ
    - yieldとか必須っぽいけど知りませんでした
        - [yieldのちょっとした理解](http://giraffe.topaz.ne.jp/wiki/doku.php/py:lesson14 "yieldのちょっとした理解")
- インタラクティブプログラムとは
    - IPythonでデモとかでモリモリ叩いている感じ
    - データ分析系の人はよく使う
    - demo
        - IPython notebook
        - webの対話環境
        - グラフとか表とか出てくる
        - DBからデータを抜いてきたりもできる
        - webで共有できる
        - !rm -rf /とかもできる
        - 危ない！
- だいたい関数で使う
- そういうのをどう作る？
- 省メモリ:
    - generatorを返す
        - generatorが帰ってきた段階では1回もfetchしてない
        - tupleの瞬間に取ってくる
        - generatorを取ってきて、forで回せば1件ずつ取ってくるのでメモリ食わない
    - ファイルをDBに書きだす
        - まとめてメモリに持っちゃうとメモリに厳しい
        - readlineで1行yieldする
    - nodejsとかだと、ストリームでデータを取ってどっかに流すみたいな書き方をよくやる
        - 貯めこまない感じ
    - @memoryprofilerをpipインストールして使うと、どれだけメモリ使ってるかはわかる
    - generatorが扱えない人はIPython Notebook使わないほうがいい
    - インタラクティブ環境だから、パラメータ無しで実行しがちだけど、それで全部取ってきたりしたら死ぬ
        - 期間指定を必須パラメータにする
    - IPython Notebook で <METHOD>? でpydoc?が見れる
        - Docstringを書いておくと便利
    - __slots__ を使う
- Notebook Serverの運用
    - 定期再起動でメモリ食ってるのを殺す
- IPython Notebook 3.0でマルチユーザ対応が入ってくるので、そこで安全系のが色々入るのでは

## Python + Hive on AWS EMRで貧者のログ集計

- AWS EMR: Hadoop
- kanmuの仕事:
    - カード会員向けのクーポン配信
- 貧者のログ集計
    - 貧者とは: 今ある状態から省リソースで目的を達成する姿勢
- 1.7G/day, 月500GB
- 構成
    - 広告配信サーバがS3にログを出す
    - S3からRDBMSにログを吐く？
- parseとcleanupはしない
- collect: Fluentdでログを飛ばす
    - ユーザのアクションをQueryStringに載せる
    - Hiveで集計時にJSONに変換
- store: S3に飛ばす
- process
    - 夜間バッチ: S3のデータをマージして集計、結果をRDBMSに突っ込む
    - 昼間クエリ: prestoがHiveのメタストアを参照
- visualization:
    - RDBMSのデータをゴニョゴニョ
- aws-cli: EMRを触れるようになった

## その他

- ランチディスカッションよかった
    - 各テーブルにコミュニティとかテーマがある中、何でもないテーブルに座って適当な話ができた
        - 参加者の名札づくりのプロセスとか
        - Djangoは割と自由が効くのでRailsに戻りたいとか
- 15時頃のBreakが長めなのもよかった
    - コーヒー飲んで甘いもの食べて頭リフレッシュ
    - ここでもテーブルをシェアした人と少し話せた
- 懇親会で気づいたら弊社の人居なくなってた
- 帰りの電車で逆方向に乗ってしまい、戻ってきたところで乗ってきたPyCon参加者に不審な目で見られた
- 2日目、海外から参加された女性の方に、"Did you ware pro-wrestring T-shirts, yestarday?"と声をかけられたので、1日目にホーガンTを着ていた私は、"Yes. And I waer pro-wrestring T-shirts Today."と、その日着ていたシェーマスTを自慢しました。
    - その方は9/15の新日を見に行くとのこと。柴田と石井をrecommendすればよかった。



